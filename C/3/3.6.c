//计算机存储二进制是用补码格式
/*
位运算(二进制运算)：
左移：<<    左移相当于乘以2的n次方，移几位就乘以2的几次方 例(移了3位)：10*2的3次方
右移：>>    右移相当于除以2的n次方，移几位就除以2的几次方 例(移了1位)：4/2的1次方
按位非：~   在二进制数中0变1，1变0  (二进制最高位是符号位0是正1是负所以正会变负，负会变正)(还需要用到源码补码反码)
按位或：|   对应位置有1为1否则为0
按位与：&   对应位置都为1结果为1，否则为0
按位异或：^ 对应位置相同为0不同为1
*/

/*
以int类型为例子，它是4字节，一字节是8位
所以10等于
0000 0000 0000 0000 0000 0000 0000 1010

左移就会变成
0000 0000 0000 0000 0000 0000 0001 0100

右移就会变成
0000 0000 0000 0000 0000 0000 0000 0101

按位非就会变成
假设在c语言中定义一个"int a =10"
所以10的原码，存储在计算机中的补码都为
0000 0000 0000 0000 0000 0000 0000 1010
进行按位非运算可得：
1111 1111 1111 1111 1111 1111 1111 0101
此数据首位为负数，所以存储在计算机中需要取得其补码
求反码可得：
1000 0000 0000 0000 0000 0000 0000 1010
在求其补码：
1000 0000 0000 0000 0000 0000 0000 1011
结果为-11

按位或就会变成
5的二进制
0000 0000 0000 0000 0000 0000 0000 0101
3的二进制
0000 0000 0000 0000 0000 0000 0000 0011
结果为
0000 0000 0000 0000 0000 0000 0000 0111

按位与就会变成
5的二进制
0000 0000 0000 0000 0000 0000 0000 0101
3的二进制
0000 0000 0000 0000 0000 0000 0000 0011
结果为
0000 0000 0000 0000 0000 0000 0000 0001

按位异或就会变成
5的二进制
0000 0000 0000 0000 0000 0000 0000 0101
3的二进制
0000 0000 0000 0000 0000 0000 0000 0011
结果为
0000 0000 0000 0000 0000 0000 0000 0110

*/

/*
二进制源码，反码，补码

原码
最高位的“0”为正数，“1”为负数.，其余位表示数据的大小
9的原码为：0000 0000 0000 0000 0000 0000 0000 1001
-9的原码为：1000 0000 0000 0000 0000 0000 0000 1001

反码
对于一个正数来说，其原反补三码为相同的，但对于负数来说，其反码为计算方式为“最高位符号位不变，其余位“1”转换成“0”，“0”转换成“1”
-9的原码为：1000 0000 0000 0000 0000 0000 0000 1001，所以
-9的反码为：1111 1111 1111 1111 1111 1111 1111 0110

补码
一个数的补码，即为其反码+1.
-9的反码为：1111 1111 1111 1111 1111 1111 1111 0110 ，所以其补码为：1111 1111 1111 1111 1111 1111 1111 0111

*/

#include <stdio.h>//打开一个工具库 stdio.h为库名
int main()//主函数：程序的入口  有且只有一个，而且必须要有一个 (头文件)
{
    //左移
    int a = 10;
    printf("%d\n",a<<3);

    //右移
    int b = 4;
    printf("%d\n",b>>1);

    //按位非
    int c = 10;
    printf("%d\n",~c);

    //按位或
    int d = 5;
    int e = 3;
    printf("%d\n",d|e);

    //按位与
    int f = 5;
    int g = 3;
    printf("%d\n",f&g);

    //按位异或
    int h = 5;
    int i = 3;
    printf("%d",h^i);
    
    return 0;//代码结束
}